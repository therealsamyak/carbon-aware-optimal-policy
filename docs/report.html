<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="noindex, nofollow" />
    <meta name="googlebot" content="noindex, nofollow" />
    <title>Report - Optimal Charge Security Camera</title>
    <link rel="stylesheet" href="styles.css" />
    <script
      id="MathJax-script"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"
    ></script>
  </head>
  <body>
    <!-- Top Navigation -->
    <nav class="top-nav">
      <a href="index.html" class="logo">OCS</a>
      <div class="nav-links">
        <a href="index.html">Home</a>
        <a href="report.html" class="active">Report</a>
        <a href="docs.html">Documentation</a>
        <a href="https://github.com/therealsamyak/ECM202A_2025Fall_Project_2" target="_blank"
          >GitHub</a
        >
      </div>
    </nav>

    <div class="layout-container">
      <!-- Sidebar -->
      <aside class="sidebar">
        <h2>Table of Contents</h2>
        <ul class="toc-links">
          <li><a href="#abstract">Abstract</a></li>
          <li><a href="#introduction">1. Introduction</a></li>
          <li><a href="#related-work">2. Related Work</a></li>
          <li><a href="#technical-approach">3. Technical Approach</a></li>
          <li><a href="#evaluation-results">4. Evaluation & Results</a></li>
          <li><a href="#discussion-conclusions">5. Discussion & Conclusions</a></li>
          <li><a href="#references">6. References</a></li>
          <li><a href="#supplementary-material">7. Supplementary Material</a></li>
        </ul>

        <div class="footer-info">
          <p><strong>Contributors:</strong><br />Samyak Kakatur, Jasper Lin</p>
        </div>
      </aside>

      <!-- Main Content -->
      <main class="main-content">
        <div class="content-wrapper">
          <h1>Optimal Charge Security Camera</h1>

          <!-- Abstract Section -->
          <section id="abstract" class="section">
            <h2>Abstract</h2>
            <p>
              Carbon awareness is becoming increasingly important in the modern world, and many
              companies are striving to be carbon-neutral in their operations. Existing research
              into carbon-aware computing has focused on high-power, high-performance computing
              systems, but there has not been any awareness into carbon-aware battery charging,
              especially for small-scale IoT devices. In this paper, we propose a controller
              framework for a battery-powered security camera that balances the tradeoff
              betweenaccuracy, latency, carbon footprint, and charging decisions based on a
              pre-defined reward function. This controller picks the optimal models and when to
              charge every task interval over a horizon of time.
            </p>
          </section>

          <!-- Introduction Section -->
          <section id="introduction" class="section">
            <h2>1. Introduction</h2>

            <h3>1.1 Motivation & Objective</h3>
            <p>
              While significant research has addressed carbon-aware computing in data centers and
              high-performance systems, small-scale IoT devices remain overlooked. Battery-powered
              devices with flexible charging represent a massive, untapped opportunity for carbon
              optimization. If they are plugged in all the time, they can charge even when it is not
              carbon-efficient to do so.
            </p>
            <p>
              Our objective is to develop an intelligent controller that optimizes both
              computational (which model to select) and charging decisions for battery-powered
              security cameras. With this approach, we can charge when it is more carbon-efficient,
              rather than always charging regardless of the carbon cost. We balance our model
              selection to account for this carbon-efficiency
            </p>
            <p>
              Because there are differences of opinion on how much each factor (accuracy, latency,
              carbon footprint, camera uptime) matters to an individual, we define a specific reward
              function that balances these factors. The system supports dynamic weights, so if the
              initial weights are not balanced to a specifc use-case, they are adjustable for other
              use-cases.
            </p>

            <h3>1.2 State of the Art & Its Limitations</h3>
            <p>
              Current carbon-aware research is focused around data-center energy considerations.
              Data centers incur large electricity costs and carbon emissions. There are 2 main
              works related to this:
            </p>
            <ul>
              <li>
                Carbon- and Precedence-Aware Scheduling for Data Processing Clusters<sup
                  id="cite-ref-2"
                  ><a href="#cite-note-2">[2]</a></sup
                >
                - This paper is focused on scheduling data center workloads such that time
                requirements are met, but we delay lower priority tasks to carbon-efficient times.
              </li>
              <li>
                Carbon-Aware Workload Management in Data Centers<sup id="cite-ref-3"
                  ><a href="#cite-note-3">[3]</a></sup
                >
                - This paper is focused on integrating energy components besides the grid, such as
                cooling, heating, solar panels, batteries, energy storage, heat pumps, and heating
                connections to maintain existing data-center workloads while minimizing carbon
                emissions.
              </li>
            </ul>

            <p>
              Both of these papers focus on large scale systems with large scale workloads. These
              approachs are not directly applicable to small-scale IoT devices, which have very
              limited bandwitdh and very small battery capacity (energy storage).
            </p>

            <h3>1.3 Novelty & Rationale</h3>
            <p>
              Our approach relies on imitating an Oracle controller. This Oracle controller can see
              into the future and has full knowledge of the carbon timeseries before it occurs.
              Using that knowledge, we can solve the full discrete MDP based on the system state
              over a given finite horizon of time. We can then train a neural network to imitate
              this Oracle Controller, giving us a controller that can make decisions in real-time.
            </p>

            <p>
              Additionally, as carbon energy generally follows a sinusoidal pattern, we can leverage
              this neural network to also gain insight on the ebb and flow of carbon timeseries,
              further giving us more optimization potential.
            </p>

            <p>
              Finally, by modelling this problem as an MDP (and POMDP), we can take advantage of
              existing solving techniques (ex. Data-driven Planning via Imitation Learning<sup
                id="cite-ref-4"
                ><a href="#cite-note-4">[4]</a></sup
              >), which are well-studied and have multiple proven solutions.
            </p>

            <h3>1.4 Potential Impact</h3>
            <p>
              This system could easily be extended to other battery-powered devices that make
              decisions. Any system with a form of energy storage and energy input can take
              advantage of our models to create their own controllers that balance clean energy.
            </p>

            <h3>1.5 Challenges</h3>
            <p>
              Implementing an energy-aware decision-making controller for battery-powered edge
              devices presents several challenges. The primary difficulty is solving and generating
              sufficient training data from the Oracle MDP, as the state and action spaces grow
              quickly even under coarse discretization. Specific examples include:
            </p>
            <ul>
              <li>
                Deciding how static or dynamic the system should be to user-input. We can allow the
                user to dynamically adjust their requirements during runtime, but adjusting an
                already trained controller could be time-consuming, complex, or expensive,
                especially as we still have to maintain our task interval.
              </li>
              <li>
                Discretization of continuous variables. More precision means more runtime, but too
                much precision can make simple calculations more complex due to floating point
                errors.
              </li>
              <li>
                Carbon patterns vary from region to region. As such, we need to ensure as vast of
                variety carbon data as possible from different times of the year for a complete
                picture.
              </li>
            </ul>

            <h3>1.6 Metrics of Success</h3>
            <p>
              We compare our trained Imitation Controller to the Oracle controller over the
              following metrics:
            </p>
            <ul>
              <li>
                Accuracy - how many times over the horizon does the model selected meet the user's
                requirements?
              </li>
              <ul>
                <li>
                  Success - number of times the selected model met the user's requirements, and had
                  enough energy to run.
                </li>
                <li>
                  Small Miss - number of times the selected model didn't meet the user's
                  requirements, and had enough energy to run.
                </li>
                <li>
                  Failure - number of times a model was unable to run, due to a lack of energy.
                </li>
              </ul>
              <li>
                Utility - differences in the rewards of the Oracle Controller and the Imitation
                Controller decisions over each horizon.
              </li>
              <li>
                "Feasibility-Normalized Effective Uptime" - at each timestep \( t \), let \( F_t \)
                be the set of models feasible under the current energy constraint, and let \( a_t^*
                = \max_{m \in F_t} a(m) \) be the best achievable accuracy. If a model \( m_t \) is
                selected and runs, the timestep is scored as \( \frac{a(m_t)}{a_t^*} \); if no model
                is ran (Failure) it scores a \( 0 \). The metric is computed as the average score
                over the horizon.
              </li>
            </ul>
          </section>

          <!-- Related Work Section -->
          <section id="related-work" class="section">
            <h2>2. Related Work</h2>

            <h3>2.1 Carbon-Aware Computing in Large-Scale Systems</h3>
            <p>
              <strong>Carbon- and Precedence-Aware Scheduling for Data Processing Clusters</strong
              ><sup id="cite-ref-2"><a href="#cite-note-2">[2]</a></sup> developed scheduling
              algorithms that delay lower-priority data center workloads to carbon-efficient times
              while meeting time requirements. The authors focused on large-scale data processing
              clusters with significant energy consumption. While their approach successfully
              reduces carbon emissions in data centers, it assumes substantial energy storage and
              computational resources unavailable to small IoT devices.
            </p>
            <p>
              <strong>Carbon-Aware Workload Management in Data Centers</strong
              ><sup id="cite-ref-3"><a href="#cite-note-3">[3]</a></sup> proposed integrating
              multiple energy components including solar panels, batteries, and energy storage
              systems to minimize carbon emissions while maintaining data center workloads. Their
              multi-energy integration approach is effective for large facilities but requires
              complex infrastructure and significant capital investment, making it unsuitable for
              individual IoT devices.
            </p>

            <h3>2.2 Planning and Control Methods</h3>
            <p>
              <strong>Data-driven Planning via Imitation Learning</strong
              ><sup id="cite-ref-4"><a href="#cite-note-4">[4]</a></sup> introduced a framework for
              training neural networks to imitate optimal planners in complex decision-making
              problems. This paper specifically addresses using imitation learning to solve POMDPs,
              which is directly relevant to our problem. However, this paper is focused on robotics
              planning, and doesn't specifically address planning based on carbon-emissions.
            </p>

            <h3>Other Related Works</h3>
            <p>
              Other works in Section VI are not as directly related to this problem as the other
              papers above are, but still give valuable insight into applications of POMDPs.
            </p>
          </section>

          <!-- Technical Approach Section -->
          <section id="technical-approach" class="section">
            <h2>3. Technical Approach</h2>
            <p>
              Describe your system, methodology, algorithms, and design choices.<br />
              Use figures generously:
            </p>
            <ul>
              <li>System architecture diagram</li>
              <li>Data pipeline</li>
              <li>Algorithm/model block diagram</li>
              <li>Hardware setup photos</li>
            </ul>
            <p>ðŸ’¡ Tip: Add images, diagrams, and code snippets. Make your system reproducible.</p>

            <h3>3.1 System Architecture</h3>
            <p>Include a block diagram or pipeline figure.</p>

            <h3>3.2 Data Pipeline</h3>
            <p>Explain how data is collected, processed, and used.</p>

            <h3>3.3 Algorithm / Model Details</h3>
            <p>Use math, pseudocode, or diagrams as needed.</p>

            <h3>3.4 Hardware / Software Implementation</h3>
            <p>Explain equipment, libraries, or frameworks.</p>

            <h3>3.5 Key Design Decisions & Rationale</h3>
            <p>Describe the main design decisions you made.</p>
          </section>

          <!-- Evaluation & Results Section -->
          <section id="evaluation-results" class="section">
            <h2>4. Evaluation & Results</h2>
            <p>
              Present experimental results with clarity and professionalism.<br /><br />
              Include:
            </p>
            <ul>
              <li>Plots (accuracy, latency, energy, error curves)</li>
              <li>Tables (comparisons with baselines)</li>
              <li>
                Qualitative visualizations (spectrograms, heatmaps, bounding boxes, screenshots)
              </li>
              <li>Ablation studies</li>
              <li>Error analysis / failure cases</li>
            </ul>
            <p>Each figure should have a caption and a short interpretation.</p>
          </section>

          <!-- Discussion & Conclusions Section -->
          <section id="discussion-conclusions" class="section">
            <h2>5. Discussion & Conclusions</h2>
            <p>
              Synthesize the main insights from your work.<br /><br />
              <strong>What worked well and why?</strong><br />
              <strong>What didn't work and why?</strong><br />
              <strong>What limitations remain?</strong><br />
              <strong>What would you explore next if you had more time?</strong><br /><br />
              This should synthesizeâ€”not merely repeatâ€”your results.
            </p>
          </section>

          <!-- References Section -->
          <section id="references" class="section">
            <h2>6. References</h2>
            <p>
              Provide full citations for all sources (academic papers, websites, etc.) referenced
              and all software and datasets uses.
            </p>

            <h3 id="cite-note-4">Data-driven Planning via Imitation Learning<cite>[4]</cite></h3>
            <p>
              Choudhury, S., Bhardwaj, M., Arora, S., Kapoor, A., Ranade, G., Scherer, S., & Dey, D.
              Data-driven Planning via Imitation Learning. The Robotics Institute, Carnegie Mellon
              University & Microsoft Research.
              <a href="https://arxiv.org/abs/2008.09719" target="_blank">[Paper]</a>
            </p>

            <h3 id="cite-note-2">
              Carbon- and Precedence-Aware Scheduling for Data Processing Clusters<cite>[2]</cite>
            </h3>
            <p>
              Lechowicz, A., Shenoy, R., Bashir, N., Hajiesmaili, M., Wierman, A., & Delimitrou, C.
              Carbon- and Precedence-Aware Scheduling for Data Processing Clusters.
              arXiv:2502.09717, 2025.
              <a href="https://arxiv.org/abs/2502.09717" target="_blank">[Paper]</a>
            </p>

            <h3 id="cite-note-3">
              Carbon-Aware Workload Management in Data Centers<cite>[3]</cite>
            </h3>
            <p>
              Nkwawir, B.W., Kayalica, M.O., Guven, D., Duman, A.C., & Erden, H.S. Carbon-Aware
              Workload Management in Data Centers: A Multi-Energy Integration Approach. In
              Proceedings of 16th ACM International Conference on Future and Sustainable Energy
              Systems (E-Energy '25), Association for Computing Machinery, New York, NY, USA,
              907â€“914.
              <a href="https://doi.org/10.1145/3679240.3735104" target="_blank">[Paper]</a>
            </p>

            <h3 id="cite-note-5">Monte-Carlo Planning in Large POMDPs<cite>[5]</cite></h3>
            <p>
              Silver, D., & Veness, J. Monte-Carlo Planning in Large POMDPs. MIT & UNSW, Sydney,
              Australia.
              <a
                href="https://davidstarsilver.wordpress.com/wp-content/uploads/2025/04/monte-carlo-planning-in-large-pomdps.pdf"
                target="_blank"
                >[Paper]</a
              >
            </p>

            <h3 id="cite-note-6">
              Optimal Control of Markov Processes with Incomplete State Information I<cite
                >[6]</cite
              >
            </h3>
            <p>
              Ã…strÃ¶m, K.J. Optimal Control of Markov Processes with Incomplete State Information I.
              In Journal of Mathematical Analysis and Applications 10. p.174-205, 1965.
              <a href="https://lup.lub.lu.se/record/8867084" target="_blank">[Paper]</a>
            </p>
          </section>

          <!-- Supplementary Material Section -->
          <section id="supplementary-material" class="section">
            <h2>7. Supplementary Material</h2>

            <h3>7.a. Datasets</h3>
            <p>Describe each dataset:</p>
            <ul>
              <li>Source and URL</li>
              <li>Data format</li>
              <li>Preprocessing steps</li>
              <li>Labeling/annotation efforts</li>
            </ul>
            <p>Include your internal dataset if you collected one.</p>

            <h3>7.b. Software</h3>
            <p>List:</p>
            <ul>
              <li>External libraries or models</li>
              <li>Internal modules you wrote</li>
              <li>Links to repos or documentation</li>
            </ul>
          </section>
        </div>
      </main>
    </div>

    <script src="script.js"></script>
  </body>
</html>
